## 일일과제

불연속할당 설명 시에 언급했던 '연결리스트' 자료구조에 대해 조사하고 정리해보자.
C언어를 이용해 연결리스트를 구현하는 예제까지 함께 첨부해서 마무리하자!

---

### 불연속 할당

- 메모리의 비어있는 공간에 데이터를 분산해서 저장하는 방식이다.

- 분산된 블록은 파일 시스템이 관리한다.

- 현실에서 잘 사용된다.

- 구현방식에 따라 "연결 할당"과 "인덱스 할당"으로 구분할 수 있다.

    - **연결 할당** : 각 블록의 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는(참조하는) 형태로 할당하는 방식이다. 연결리스트라는 자료구조를 이용하면 관리할 수 있는 방식이다. 연결리스트의 각 노드는 해당 블록의 데이터와 다음 블록의 주소를 함께 보유하기 때문에 메모리 공간이 서로 떨어져 있어도 아무런 문제가 되지 않는다.

    - **인덱스 할당** : 파일의 모든 블록 주소를 '인덱스 블록'이라는 별도의 블록에 따로 모아서 관리하는 방식이다. 만약 4개의 블록이 필요한 파일 하나가 있으면 추가로 한 개를 더해서 5개의 블록을 갖게 하고 그 중 하나의 블록에 블록에 대한 주소 정보를 따로 저장한다.

### '연결리스트' 자료구조

**연결리스트(linked list)**는 대표적인 선형 자료구조의 하나로, 배열과 달리 크기가 정해져 있지 않은 동적(dynamic) 자료구조이다. 이는 연결리스트가 여러 개의 노드(node)로 구성되기 때문이다. 노드는 데이터와 다음 노드가 저장돤 주솟값을 가지고 있다.

연결리스트는 헤드(head) 포인터와 테일(tail) 포인터로 시작과 끝은 알 수 있다. 연결리스트에서 첫 번째 노드는 헤더 포인터를 가리키고, 마지막 노드는 가리킬 다음 노드가 없다. 따라서 다음 노드를 가리키는 주솟값이 NULL이다. 마지막 노드는 테일 포인터가 가리킨다.

즉, 연결리스트는 노드를 이용해 메모리 공간에 데이터를 불연속적으로 저장한다. 각 노드는 데이터와 다음 노드의 주솟값을 저장하고 있어 다른 노드에 접근할 수 있다. 인덱스가 없어 한 번에 특정 데이터에 접근할 수는 없지만, 데이터의 삽입과 삭제 시 노드가 가리키는 주솟값만 변경하면 되어서 속도가 빠르다는 장점이 있다.


```C

// 구조체를 활용해서 정의한다.
// 단일 연결리스트

struct Linked_List 
{
    int number;
    char name[20];
    ...
    struct Linked_List *next;
};

// 연결리스트 데이터 하나의 노드는 구조체 인스턴스 한 개에 대응한다.
// 이 안에 넣고자 하는 데이터를 넣고, 다음 노드의 위치를 표시해주는 포인터를 포함시키면 연결리스트가 정의된다.
// Previous -> 다중 연결리스트

struct Linked_List* Previous;

// 사용할 때는 head->next->next->name 하는 식으로 사용한다.
// 노드 조회 메서드

List * get(int index) 
{
  List *head = HEAD;
  List *cur = head;

  for(int i=0; i<index; ++i) 
  {
    cur = cur->next;
  }
  return cur;
}

```