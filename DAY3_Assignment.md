## 일일 과제 - 데드락과 식사하는 철학자 문제

### 데드락 (Deadlock)

**"데드락(Deadlock)"**

프로세스들은 서로 다른 프로세스의 작업이 끝나길 기다린다. 그러나 기다리는 대상이 꼬리에 꼬리를 물고 이어져서 결국 아무도 작업을 진행하지 못하는 상태에 빠지는 경우도 발생한다. 즉, 운영체제 또는 소프트웨어의 잘못된 자원 관리로 인하여 둘 이상의 프로세스 또는 스레드들이 아무것도 진행하지 않는 상태로 서로 영원히 대기하는 상황이다.

데드락은 한정된 자원을 둘 이상의 주체가 서로 동시에 사용하려고 기다리기 때문엔 발생한다고 할 수 있으며, 이것은 데드락이 발생하는 이유가 "공유자원" 때문이라 할 수 있다.

데드락은 아무때나 발생하지 않는다. 다음과 같이 네 가지 조건이 만족되는 경우에만 데드락이 발생할 **가능성**이 있다. (조건을 다 충족했다고 무조건 발생하는 것은 아니다. 네 가지 중 한 가지라도 충족하지 않으면 데드락은 발생하지 않는다.)

- **상호배제 (Mutual exclusion)**

    - 어떤 프로세스가 어떤 공유자원을 사용하고 있다면, 해당 공유자원은 다른 프로세스가 접근할 수 없어야 한다.

- **비선점 (No preemption)**

    - 어떤 프로세스가 공유자원을 가지고 있을 때, 다른 프로세스가 이것을 빼앗을 수 없어야 한다.

- **점유 및 대기 (Hoid and wait)**

    - 어떤 프로세스가 공유자원을 가지고 있는 상태일 때, 다른 프로세스가 그 자원을 사용하기 위해 기다리고 있어야만 한다.

- **원형(환형) 대기 (Circular waite)**

    - 점유 및 대기를 하는 프로세스들의 관계가 꼬리에 꼬리를 물어서 둥글게 형성이 되어 있는 상황이어야 한다.

### 식사하는 철학자 문제 (Dining philosophers problem)

"식사하는 철학자 문제"란 1965년 에츠허르 데이크스트라(Edsger Wybe Dijkstra)라는 네덜란드 출신의 컴퓨터 과학자가 운영체제의 교착상태, 즉 데드락을 설명하기 위해 만든 문제이다.

![image](https://github.com/Hjoowhi/os/assets/157435520/105f9ad8-5b1d-43a5-afa3-679d5d4197b7)


```

다섯 명의 철학자가 하나의 원탁에 앉아 식사를 한다. 각각의 철학자들 사이에는 포크가 하나씩 있고, 앞에는 접시가 있다.
접시 안에 든 요리는 포크를 두 개 사용하여 먹어야만 하는 스파게티이다.
그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없으며, 번갈아가며 각자 식사하거나 생각하는 것만 가능하다.
따라서 식사를 하기 위해서는 왼쪽과 오른쪽의 인접한 철학자가 모두 식사를 하지 않고 생각하고 있어야만 한다.
또한 식사를 마치고 나면, 왼손과 오른손에 든 포크를 다른 철학자가 쓸 수 있도록 내려놓아야 한다.
이때, 어떤 철학자도 굶지 않고 식사할 수 있도록 하는 방법은 무엇인가?

```

위와 같은 상황을 가정하고, 각 철학자들이 식사를 하는 연속된 과정을 생각해본다.

```

1. 일정 시간 생각을 한다.

2. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용가능하다면 집어든다.

3. 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용가능하다면 집어든다.

4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.

5. 오른쪽 포크를 내려놓는다.

6. 왼쪽 포크를 내려놓는다.

7. 다시 1번으로 돌아간다.

```

왼쪽 포크와 오른쪽 포크를 한번에(atomic) 가져오는 것이 아니라 순서대로(sequentially) 가져오기 때문에, 모두가 왼쪽 포크부터 집어드는 단순한 알고리즘을 가지고 있으면 문제가 생길 수밖에 없다. 5명의 철학자 전부 왼쪽 포크를 들고 있다면 오른쪽 포크를 얻으려고 할 때 오른쪽 포크는 이미 상대방이 가져간 상태가 된다. 이렇게 원탁을 한 바퀴 돌 때까지 모든 철학자들이 3번 상태에 머무르게 되고 자신의 오른쪽 포크가 사용 가능해질 때까지 영원히 기다리고만 있어야 하는 것이다. 

철학자가 포크를 사용하고 있을 때, 해당 포크에 다른 철학자가 접근하지 못하는 "상호배제", 철학자가 가지고 있는 포크를 다른 철학자가 빼앗을 수 없는 "비선점", 철학자가 포크를 사용 중일 때, 그 포크를 사용하기 위해 기다려야 하는 "점유 및 대기", 이런한 상태의 철학자들이 꼬리에 꼬리를 물어 둥글게 형성된 "원형 대기"의 조건들이 충족되어 ***"데드락"***이 발생할 수도 있는 것이다.

이때 양쪽 포크를 집을 수 없어 식사를 하지 못하는, 즉 프로세스가 자원을 계속 할당받지 못하는 기아 상태가 발생할 수 있다.

데드락을 예방하고자 하는 경우에는 위에서 언급한 데드락 발생 조건 4가지 중 한 가지를 제거하면 된다.

- **상호배제 부정** : 여러 프로세스가 동시에 하나의 공유 자원을 사용할 수 있게 한다.

- **비선점 부정** : 자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원을 반납하게 한다.

- **점유와 대기 부정** : 프로세스가 실핼되기 전에 필요한 모든 자원을 할당함으로써 프로세스 대기를 없앤다. 또는 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요구하게 한다.

- **환형 대기 부정** : 자원을 선형 순서로 정렬해 고유 번호를 할당한다. 그리고 각 프로세스에서 요구할 수 있는 번호의 방향을 정해서 한쪽 방향으로만 자원을 요구하게 한다.

---

<참고>

"식사하는 철학자 문제," 나무위키,
https://namu.wiki/w/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94%20%EC%B2%A0%ED%95%99%EC%9E%90%20%EB%AC%B8%EC%A0%9C

이수진, 기술면접대비 CS전공 핵심요약집 중 "프로세스" (길벗, 2023), 36-37.
